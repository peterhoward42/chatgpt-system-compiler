o  DOCUMENT ROLE AND SCOPE (UNIFIED, MUST)

This document is the single source of truth for the DrawExact telemetry system and
the experimental, compiler-style process used to generate and evolve its code. It
defines the deployed runtime system, the intended interaction model between the
human author and ChatGPT, the required repository artefacts, and the regeneration
philosophy guiding iteration. It governs both runtime behaviour and generative
process. It does not define DrawExact product logic beyond telemetry ingestion and
analysis.


o  COMPLIANCE WITH RFC-STYLE REQUIREMENTS (MANDATORY)

- MUST-COMPLIANCE RULE  
  All MUST requirements in this spec are mandatory. The generator MUST NOT
  silently downgrade a MUST requirement to a SHOULD or MAY.

- INFEASIBILITY OR CONFLICT HANDLING  
  If two or more MUST requirements conflict, or if any MUST requirement cannot
  be satisfied within the constraints of the requested implementation, the
  generator MUST:

  (a) explicitly identify each unsatisfied or conflicting MUST requirement,  
  (b) explain the minimal, concrete reason why each such MUST cannot be met, and  
  (c) propose one or more specific spec edits or design alternatives that would
      resolve the conflict or infeasibility.

- DEVIATION REGISTER (MANDATORY OUTPUT)  
  In the case of any unsatisfied or conflicting MUST requirement, the generated
  output MUST include a plain-text deviation register file. This file MUST:

  - list each unsatisfied or conflicting MUST requirement verbatim,
  - describe the minimal reason it could not be satisfied,
  - indicate whether the issue is due to an internal design conflict, an external
    constraint, or missing/ambiguous specification, and
  - reference the affected components or behaviours.

  The deviation register MUST be clearly named (e.g. DEVIATION_REGISTER.txt) and
  treated as part of the generated artefacts.

- PARTIAL OUTPUT RULE  
  The generator MAY still produce a partial implementation when MUST
  requirements cannot be met, but it MUST clearly label the implementation as
  non-compliant and MUST reference the deviation register as the authoritative
  record of outstanding violations.

- TRADEOFF PREFERENCE RULE  
  When multiple designs satisfy all MUST requirements, the generator SHOULD
  prefer designs that satisfy the greatest number of SHOULD requirements. Any
  significant SHOULD requirements that are not satisfied SHOULD be noted in
  comments or documentation, but need not appear in the deviation register.

- TESTING CLAIMS SAFETY RULE  
  If any MUST requirement in the testing or verification sections of the spec
  cannot be met, the generator MUST NOT claim that the test suite fully validates
  system behaviour. The generated documentation MUST explicitly state which
  behaviours, rules, or branches remain unvalidated and reference the deviation
  register.


o  ORTHOGONAL PLANES MODEL (UNIFIED, MUST)

This document is organised into orthogonal conceptual planes. System plane sections
define runtime behaviour, interfaces, data formats, and invariants of the deployed
service. Generation plane sections constrain how ChatGPT must generate code and
collaborate with the author. Tooling plane sections define repository artefacts and
developer-facing operations. Sections explicitly state which plane they govern and
which they do not.

o  GENERATION MODEL (GENERATION PLANE, MUST)

ChatGPT must behave as a compiler. For each iteration, the entire codebase must be
generated afresh from the current specification without reliance on previous
generated output. There is no expectation of preserving diffs between iterations.
Global coherence and correctness take precedence over local stability.

o  ITERATION AND COLLABORATION MECHANICS (GENERATION PLANE, MUST)

The human author iteratively refines the specification. After each refinement,
ChatGPT must generate a complete, globally consistent codebase satisfying the
specification. Large changes between iterations are intentional and acceptable.

o  AMBIGUITY RESOLUTION POLICY (GENERATION PLANE, MUST)

ChatGPT must assume rather than ask whenever possible. Ambiguity must be resolved
conservatively. Any assumptions required to complete generation must be made
explicit in code comments and should be recorded in an assumptions log. Simplicity
is preferred over cleverness. Avoiding duplication matters, but DRY does not
override clarity.

o  SYSTEM OVERVIEW (SYSTEM PLANE, MUST)

The system is a cloud-hosted HTTP API that receives runtime telemetry events from
the DrawExact web application, persists them at low cost, and exposes a live
analysis endpoint that computes aggregate user behaviour metrics derived from the
stored events.

o  PLATFORM AND DEPLOYMENT MODEL (SYSTEM PLANE, MUST)

The system must be implemented as a single Google Cloud Function deployed as a
single deployment. Ingestion and analysis must be exposed on the same public HTTPS
endpoint. The API is public and callable from browsers.

The Google Cloud Functions framework must be used and the deployment must be
source-based. The entry point function must be named InjestEvent and must live in
the root package. The root package must not be named main. The repository must not
include a local runner such as cmd/main.go.

o  GO TOOLCHAIN AND MODULE FILES (SYSTEM PLANE, MUST)

The implementation must use Go version 1.25, declared in go.mod using standard Go
module syntax. A go.mod file must be generated including the module name and all
required dependencies. A go.sum file must not be generated or committed. Any
external requirement for go.sum does not alter this rule unless explicitly stated
in a future specification revision.

o  CONFIGURATION POLICY (SYSTEM PLANE, MUST)

The deployed function URL is
https://service-injest-event-65030510907.europe-west2.run.app

The system must not use environment variables for non-secret configuration. All
non-secret configuration values must be compile-time constants. Changing
configuration requires redeployment.

o  TELEMETRY EVENT MODEL (SYSTEM PLANE, MUST)

The EventPayload schema is defined as follows.

SchemaVersion is an integer and must equal 1.

EventULID is a string and must be a valid ULID. Validation must perform strict ULID
parsing rather than relying on string length.

ProxyUserID is a string and must be a UUID version 4. It serves as the anonymised
DrawExact user identifier.

TimeUTC is a string and must parse as an RFC3339 timestamp. All timestamp semantics
are UTC.

Visit is an integer representing the session count at emission time and must lie
between 1 and 100000 inclusive.

Event is a string naming the event type. Its length must be between 4 and 40
characters. Its value must be exactly one of the following strings: launched,
quit, sign-in-started, sign-in-success, recoverable-javascript-error,
fatal-javascript-error, loaded-example, created-new-drawing,
retreived-save-drawing.

Parameters is a string containing event-specific opaque data. Its maximum length
is 80 characters. No structural guarantees are made about its contents.

o  PAYLOAD VALIDATION POLICY (SYSTEM PLANE, MUST)

All ingested payloads must satisfy the telemetry event model constraints. Payload
validation is the primary abuse mitigation strategy and enforces reasonable and
plausible input. The system is not intended to be adversarially robust.

o  HTTP INTERFACE (SYSTEM PLANE, MUST)

Permissive CORS must be supported. The Access-Control-Allow-Origin response header
must be set to "*". OPTIONS preflight requests must be handled correctly.

A POST request to the root path ingests a telemetry event. The Content-Type must be
application/json. The body must contain a JSON representation of EventPayload. On
success, the response must be HTTP 204 with no body. Invalid payloads must result
in HTTP 400. Unsupported content types must result in HTTP 415. Storage failures
must result in HTTP 500.

A GET request to the root path performs a live aggregate analysis. The request
accepts no parameters. On success, the response must be HTTP 200 with a JSON body
matching the analysis schema. Failures must result in HTTP 500.

o  PERSISTENCE STRATEGY (SYSTEM PLANE, MUST)

Telemetry events must be persisted using Google Cloud Storage. The storage bucket
must be named drawexact-telemetry. Each event must be stored as a separate object.
Objects are append-only and must not be modified after creation.

Object contents must be gzip-compressed. When decompressed, each object must
contain exactly one NDJSON line encoding a single EventPayload, followed by a
newline character.

o  STORAGE OBJECT NAMING (SYSTEM PLANE, LOCKED)

Each telemetry event object must be stored with an object name of the form
events/y=YYYY/m=MM/d=DD/hour=HH/EventULID.ndjson.gz. The year, month, day, and hour
must be extracted from EventPayload.TimeUTC. EventULID must be taken directly from
EventPayload.EventULID. The events/ prefix is constant.

o  ANALYSIS INTERFACE AND SCHEMA (SYSTEM PLANE, MUST)

The system must expose exactly one analysis operation via HTTP GET at the root
path. Analysis must be computed live on each request. No parameters are accepted
and no caching is performed.

The response must be JSON containing an object HowManyPeopleHave with integer
fields Launched, LoadedAnExample, TriedToSignIn, SucceededSigningIn,
CreatedTheirOwnDrawing, and RetreivedTheirASavedDrawing. The response must also
contain integer fields TotalRecoverableErrors and TotalFatalErrors.

o  ANALYSIS SEMANTICS (SYSTEM PLANE, MUST)

A distinct person is defined as a distinct ProxyUserID. Analysis is performed over
the entire stored event history without time windowing.

For each behaviour metric, the value represents the count of distinct ProxyUserID
values for which at least one corresponding event exists. TotalRecoverableErrors
and TotalFatalErrors represent total event counts, not distinct users.

Malformed stored event objects encountered during analysis must be skipped.
Analysis must not fail solely due to malformed historical data.

o  ANALYSIS MEMORY CONSTRAINTS (SYSTEM PLANE, ASSUME)

It is assumed that the complete set of stored telemetry objects is small enough to
be read fully into memory during analysis.

o  SECURITY AND ABUSE MODEL (SYSTEM PLANE, MUST)

The API is public. The only mitigated threat model is deliberate malevolent or
mischievous misuse. Validation for reasonableness and plausibility is considered
sufficient. The system does not attempt to mitigate denial-of-service attacks
beyond relying on Google Cloud infrastructure.

o  OPERATIONAL CHARACTERISTICS (SYSTEM PLANE, ASSUME)

A typical user session is assumed to produce approximately twenty events, last
roughly two hours, and occur once per day. The initial user population is assumed
to be on the order of five thousand users. Occasional dropped events are
acceptable. Latency is not critical. Cost minimisation is the primary operational
driver.

o  LOGGING POLICY (SYSTEM PLANE, MUST)

All errors must be logged to STDOUT so they are visible in the Google Cloud
dashboard. No other logging is permitted.

o  CODE ORGANISATION AND SEPARATION OF CONCERNS (GENERATION PLANE, SHOULD)

Generated code should separate concerns to maximise readability and to make the
public entrypoint(s) easy to test end-to-end using faked external interfaces.
Separation should be reflected in package structure, file structure, and
abstractions where they simplify reasoning. Simple designs are preferred over
clever ones.

The architecture should make it possible (but not necessary) to unit-test internal
components when fixturing is genuinely simpler; however, correctness evidence for
externally visible behaviour must primarily come from tests that drive the system
through its public interface(s).

o  TESTABILITY AND STRUCTURAL CONTRACT (GENERATION PLANE, MUST)


All interactions with external systems must be isolated behind minimal capability
interfaces defined in production code. Interfaces must describe required
capabilities rather than concrete technologies. Deterministic core logic must
depend only on these interfaces.

PUBLIC-INTERFACE-FIRST TESTING (MANDATORY)

Tests must validate behaviour primarily via the system’s public entrypoint(s).
For this system, the public entrypoint is the deployed Cloud Function handler
InjestEvent receiving HTTP requests at the root path.

Accordingly:

Tests MUST exercise production behaviour by constructing HTTP requests and
  asserting on HTTP responses and externally observable effects, using fake
  implementations of all external capability interfaces.

Tests MUST cover the HTTP surface of the entrypoint, including:
  - OPTIONS (CORS preflight) behaviour
  - POST ingest behaviour (success, invalid payload, unsupported content type,
    storage failure)
  - GET analysis behaviour (success, storage failure)
- Tests MUST NOT import, call, or construct internal/private modules, helpers, or
  functions solely for testing convenience. (If a package or symbol is not part
  of the explicitly defined public interface, tests must not depend on it.)
- Tests MUST NOT assert on internal implementation details (private state,
  intermediate values, internal call order). Assertions must be expressed in
  terms of public outputs and externally observable effects only.

REACHABILITY OF BUSINESS-RULE BRANCHES (MANDATORY)

All business-rule decisions (branching logic) MUST be reachable from the public
entrypoint by varying:
(a) request inputs and/or
(b) the behaviour and returned data of faked capability interfaces (ports).

Business logic MUST NOT depend on hidden global state or derived inputs that
cannot be controlled via request inputs or injectable ports. If a business rule
branches on a value X, then X MUST come from either the request or a port method
return value (including values computed from port return values inside the pure
core).

Ports SHOULD be designed so tests can independently vary each dimension that
affects business rules (e.g. user attributes, feature flags, prior state) without
adding test-only parameters to the public interface.

(For other projects: if queue subscribers, scheduled triggers, or other non-HTTP
invocations are part of the externally visible contract, they MAY be treated as
additional public entrypoints and MUST be tested via their real invocation shape
using faked external interfaces, following the same principles above.)

FAKES, NOT REIMPLEMENTATION

Tests must not reimplement business logic. Tests may construct inputs, supply fake
implementations, and assert observable outputs or effects. Fakes may provide
inspection through public, behaviour-relevant observations (e.g. “objects written”
or “data stored”), but tests must not mirror the code’s internal algorithms.

OPTIONAL INTERNAL UNIT TESTS (PERMITTED, BUT NOT PRIMARY)

Internal unit tests MAY be added only when they materially simplify fixturing for
hard-to-reach edge cases. If present, such tests:
- MUST NOT be the sole or primary evidence for any externally visible behaviour.
  For each externally visible behaviour, at least one test MUST exercise the real
  public entrypoint via HTTP using fake external interfaces.
- MUST remain resilient to refactoring by avoiding assertions about internal call
  structure and by focusing on stable contracts.

INJECTABILITY REQUIREMENTS

Access to time, randomness, configuration, or environment must be injectable.
Core logic must not call system time or random generators directly. Configuration
must follow the system-plane configuration policy (compile-time constants for
non-secrets), but any time/randomness used in logic must be supplied as an
argument or via an injected interface so tests are deterministic


o  COMMENTING RULES (GENERATION PLANE, MUST)

All exported names must be commented using concise role-oriented descriptions.
Non-exported names should be commented where helpful for overview reading.
Comments should explain non-obvious choices and subtle effects and should remain
short.

o  REPOSITORY ARTEFACTS (TOOLING PLANE, MUST)

The generated repository must include this specification verbatim in the root
directory. A README must be included and must do nothing except point to the
originating specification file.

o  MAKEFILE OPERATIONS (TOOLING PLANE, SHOULD)

The repository should include a Makefile providing targets for deployment and
demonstrating example ingest and analysis requests. Targets must not require
interactive input.

o  ASSUMPTIONS TRACKING MECHANISM (TOOLING PLANE, SHOULD)

The repository should include a plain-text assumptions log recording
implementation assumptions not explicitly stated in this specification. Each
assumption should reference relevant source files and searchable comment text.

o  NON-GOALS (NON-GOALS)

The system does not attempt to provide authentication or identity management,
event deduplication or exactly-once semantics, denial-of-service mitigation beyond
platform defaults, local execution or emulation, background aggregation, or cached
analysis.